
    <!DOCTYPE html>
        <html lang="es">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>üìÅ</title>
            <style>
      html,
      body {
        height: 100%;
        width: 100%;
        margin: 0px;
      }
      main {
        display: flex;
        flex-direction: column;
        height: 100%;
        margin: 0 50px;
      }
      .files {
        display: flex;
        gap: 1em;
        flex-wrap: wrap;
        margin-bottom: 1em;
      }
      .main-files {
        flex-grow: 1;
        gap: 1em;
      }
      .folder {
        padding: 0.2em 1.2em;
        padding-bottom: 2em;
        border: 1px;
        border-color: black;
        border-style: solid;
        border-radius: 0.2em 0.2em 0 0;
        background-color: rgb(255, 245, 106);
        height: fit-content;
      }
      .folder:hover {
        background-color: rgb(197, 189, 82);
      }
      img {
        max-width: 400px;
        max-height: 400px;
        height: auto
      }
      .iframe-div{
            width: fit-content;
        }
      .file-name {
        margin: 0px;
        display: block;
      }
      .footer {
        text-align: end;
      }
      .text-content {
        max-width: 400px;
        max-height: 400px;
        overflow: auto;
      }
      .code-file {
        max-width: 400px;
        max-height: 400px;
        overflow: auto;
        border: 1px;
        border-color: grey;
        border-style: solid;

      }
      model-viewer {
        width: 400px;
        height: 400px;
      }
      iframe {
        width: 400px;
        height: 400px;
      }
      .link-file{
        max-width: 400px;
        line-break:anywhere;
      }
      .video-file{
        max-width: 400px;
        max-height: 400px;
      }
      pre{
        margin: 0px;
      }
      header {
        background-color: rgb(145, 145, 145);
        color: black;
        padding: 0px 3px;
      }
      h3{
        margin: 0;
      }
      /* Extra small devices (phones, 600px and down) */
      @media only screen and (max-width: 800px) {
        .folder {
          padding: 0 0.3em;
        }
        .files {
          gap: 0.5em;
        }
        h1 {
          font-size: x-large;
        }
        main {
          margin: 0 10px;
        }
        iframe {
          width: 100%;
          height: 400px;
        }
        .iframe-div{
            width: 100%;
        }
        img{
          width: 100%;
          height: auto;
        }
        .image-div{
          width: 100%;
        }
        model-viewer {
        width: 100%;
        height: 400px;
      }
      .model-div{
        width: 100%;
      }
      }
    </style>
        </head>
        <body>
        <header>
            <h3>Change character: <a href="/linear">linear-character</a> / <a href="/files">files-character</a></h3>
        </header>
        <main>
    
        <h1>/project/dis3Dbusi/godotVersion/scripts/dis3Dbusi/classes/tiposArchivos</h1>
            <div class="files">
                <a  href="/files/project/dis3Dbusi/godotVersion/scripts/dis3Dbusi/classes"><p>&#8604;back</p></a>
                
            </div>
            <div class="files main-files">
                
    <div class="code-div">
        <div class="link-file">
        <a class="file-name" href="/project/dis3Dbusi/godotVersion/scripts/dis3Dbusi/classes/tiposArchivos/video.gd">video.gd</a>
        </div>
        <pre class="code-file"><code>extends Node3D
class_name Video

var video_scene_path = &quot;res://scenes/files/video.tscn&quot;
var auto_play: bool = true
var loop_video: bool = true
var volume_db: float = 0.0
var MAX_SIZE: float = 2.0

# üîä Par√°metros para audio 3D
var enable_3d_audio: bool = false
var unit_size: float = 10.0
var max_distance: float = 10.0
var attenuation_model: AudioStreamPlayer3D.AttenuationModel = AudioStreamPlayer3D.ATTENUATION_INVERSE_DISTANCE

# Variables para tracking del video actual
var current_video_path: String = &quot;&quot;
var current_video_real_path: String = &quot;&quot;

# Funci√≥n principal: crear y configurar una escena de video
func crear_escena_video(video_path: String, audio_3d: bool = false) -&gt; Node3D:
	print(&quot;üé¨ [Video] Iniciando creaci√≥n de escena para: &quot;, video_path)
	enable_3d_audio = audio_3d
	
	# Guardar paths para uso posterior
	current_video_path = video_path
	current_video_real_path = _get_real_path(video_path)
	print(&quot;üé¨ [Video] Path real: &quot;, current_video_real_path)
	
	# Cargar la escena de video
	var video_scene = ResourceLoader.load(video_scene_path)
	if not video_scene:
		print(&quot;‚ùå Error: No se pudo cargar la escena de video en: &quot;, video_scene_path)
		return null
	
	# Instanciar la escena
	var video_instance = video_scene.instantiate()
	video_instance.scene_file_path = &quot;&quot;
	
	# Buscar componentes
	var video_player = _encontrar_video_player(video_instance)
	var mesh_instance = _encontrar_mesh_instance(video_instance)
	
	if not video_player or not mesh_instance:
		print(&quot;‚ùå Error: Componentes faltantes en la escena de video&quot;)
		video_instance.queue_free()
		return null
	
	# Cargar el stream de video
	var video_stream = ResourceLoader.load(video_path)
	if not video_stream or not video_stream is VideoStream:
		print(&quot;‚ùå Error: No se pudo cargar el video: &quot;, video_path)
		_mostrar_ayuda_formato()
		video_instance.queue_free()
		return null
	
	# üîä Configurar audio 3D ANTES de configurar el video player
	var audio_player_3d = null
	if enable_3d_audio:
		audio_player_3d = _configurar_audio_3d(video_instance)
		if not audio_player_3d:
			print(&quot;‚ö†Ô∏è [Audio3D] No se pudo configurar, usando audio normal&quot;)
			enable_3d_audio = false
	
	# Configurar el video player (silenciado si hay audio 3D)
	_configurar_video_player(video_player, video_stream, enable_3d_audio)
	
	# Configurar el mesh para mostrar el video
	_configurar_mesh_video(mesh_instance, video_player)
	
	# Configurar UI y controles
	_configurar_controles_ui(video_instance, video_path, video_player)
	
	# Configurar autoplay en runtime
	if auto_play:
		_configurar_autoplay_runtime(video_instance, video_player, audio_player_3d)
	
	# Hacer nodos locales y configurar nombre
	_hacer_nodos_locales(video_instance)
	_configurar_nombre_unico(video_instance)
	
	if Engine.is_editor_hint():
		video_instance.set_display_folded(true)
	
	var status = &quot;Audio 3D&quot; if enable_3d_audio else &quot;Audio Normal&quot;
	print(&quot;‚úÖ [Video] Creado correctamente con &quot;, status)
	
	return video_instance

# üîä Configurar audio 3D separado
func _configurar_audio_3d(video_instance: Node3D) -&gt; AudioStreamPlayer3D:
	print(&quot;üîä [Audio3D] Iniciando configuraci√≥n...&quot;)
	
	# Buscar archivo de audio separado  
	var audio_path = _buscar_archivo_audio_separado()
	if not audio_path:
		print(&quot;‚ùå [Audio3D] No se encontr√≥ archivo de audio separado&quot;)
		_mostrar_ayuda_audio_3d()
		return null
	
	print(&quot;üéµ [Audio3D] Archivo encontrado: &quot;, audio_path)
	
	# Cargar el stream de audio
	var audio_stream = ResourceLoader.load(audio_path)
	if not audio_stream or not audio_stream is AudioStream:
		print(&quot;‚ùå [Audio3D] Error cargando audio: &quot;, audio_path)
		return null
	
	# Crear y configurar AudioStreamPlayer3D
	var audio_player_3d = AudioStreamPlayer3D.new()
	audio_player_3d.name = &quot;AudioPlayer3D&quot;
	audio_player_3d.stream = audio_stream
	audio_player_3d.volume_db = volume_db
	audio_player_3d.unit_size = unit_size
	audio_player_3d.max_distance = max_distance
	audio_player_3d.attenuation_model = attenuation_model
	
	# Configurar loop si es necesario
	if loop_video:
		_configurar_loop_audio_3d(audio_stream)
	
	# A√±adir al √°rbol
	video_instance.add_child(audio_player_3d)
	
	print(&quot;‚úÖ [Audio3D] Configurado correctamente&quot;)
	return audio_player_3d

# üîç Buscar archivo de audio separado
func _buscar_archivo_audio_separado() -&gt; String:
	if current_video_real_path == &quot;&quot;:
		print(&quot;‚ùå [Audio3D] Path del video no disponible&quot;)
		return &quot;&quot;
	
	# Obtener el nombre base sin extensi√≥n
	var base_name = current_video_real_path.get_file().get_basename()
	var directory = current_video_real_path.get_base_dir()
	
	print(&quot;üîç [Audio3D] Buscando audio para: &quot;, base_name)
	print(&quot;üîç [Audio3D] En directorio: &quot;, directory)
	
	# Posibles sufijos y extensiones
	var suffixes = [&quot;_audio&quot;, &quot;_sound&quot;, &quot;_3d&quot;, &quot;&quot;]
	var extensions = [&quot;.ogg&quot;, &quot;.wav&quot;, &quot;.mp3&quot;]
	
	# Buscar combinaciones
	for suffix in suffixes:
		for extension in extensions:
			var audio_filename = base_name + suffix + extension
			var full_audio_path = directory + &quot;/&quot; + audio_filename
			
			print(&quot;üîç [Audio3D] Probando: &quot;, full_audio_path)
			
			# Verificar si el archivo existe
			if FileAccess.file_exists(full_audio_path):
				print(&quot;‚úÖ [Audio3D] Encontrado: &quot;, full_audio_path)
				return full_audio_path
			
			# Tambi√©n probar sin el directorio (path relativo)
			if FileAccess.file_exists(audio_filename):
				print(&quot;‚úÖ [Audio3D] Encontrado (relativo): &quot;, audio_filename)
				return audio_filename
	
	return &quot;&quot;

# Configurar loop para audio 3D
func _configurar_loop_audio_3d(audio_stream):
	if audio_stream.has_method(&quot;set_loop&quot;):
		audio_stream.set_loop(true)
	elif &quot;loop&quot; in audio_stream:
		audio_stream.loop = true

# Configurar video player
func _configurar_video_player(video_player: VideoStreamPlayer, video_stream: VideoStream, silenciar: bool = false):
	video_player.stream = video_stream
	
	if silenciar:
		video_player.volume_db = -80  # Silenciar para usar audio 3D
		print(&quot;üîá [Video] Audio silenciado - usando Audio 3D separado&quot;)
	else:
		video_player.volume_db = volume_db
	
	if loop_video:
		video_player.loop = true
	
	# No reproducir autom√°ticamente en el editor
	if auto_play and not Engine.is_editor_hint():
		video_player.play()

# Configurar mesh para mostrar video
func _configurar_mesh_video(mesh_instance: MeshInstance3D, video_player: VideoStreamPlayer):
	var material = StandardMaterial3D.new()
	material.cull_mode = BaseMaterial3D.CULL_DISABLED
	material.shading_mode = BaseMaterial3D.SHADING_MODE_UNSHADED
	
	# Duplicar mesh para evitar compartir recursos
	var quad_mesh: QuadMesh
	if mesh_instance.mesh and mesh_instance.mesh is QuadMesh:
		quad_mesh = mesh_instance.mesh.duplicate()
	else:
		quad_mesh = QuadMesh.new()
	
	# Calcular tama√±o proporcional
	var video_size = _obtener_dimensiones_video(video_player)
	var size = _calcular_tama√±o(int(video_size.x), int(video_size.y))
	
	quad_mesh.size = size
	quad_mesh.material = material
	mesh_instance.mesh = quad_mesh
	
	print(&quot;‚úÖ [Video] Mesh configurado: &quot;, video_size, &quot; -&gt; &quot;, size)

# Obtener dimensiones del video
func _obtener_dimensiones_video(video_player: VideoStreamPlayer) -&gt; Vector2:
	# En runtime, usar textura si est√° disponible
	if not Engine.is_editor_hint() and video_player.is_playing():
		var video_texture = video_player.get_video_texture()
		if video_texture and video_texture.get_width() &gt; 0:
			return Vector2(video_texture.get_width(), video_texture.get_height())
	
	# Fallback: proporciones por defecto
	if Engine.is_editor_hint():
		return Vector2(1080, 1080)  # Cuadrado para editor
	else:
		return Vector2(1920, 1080)  # 16:9 para runtime

# Configurar controles UI
func _configurar_controles_ui(video_instance: Node3D, video_path: String, _video_player: VideoStreamPlayer):
	# Configurar t√≠tulo
	var titulo_label = video_instance.find_child(&quot;TituloVideo&quot;, true, false)
	if titulo_label and titulo_label is Label3D:
		var nombre_archivo = current_video_real_path.replace(&quot;res://&quot;, &quot;&quot;)
		if enable_3d_audio:
			nombre_archivo += &quot; [3D Audio]&quot;
		titulo_label.text = nombre_archivo
		print(&quot;‚úÖ [UI] T√≠tulo configurado: &quot;, nombre_archivo)
	
	# Configurar contador
	var contador_label = video_instance.find_child(&quot;ContadorTiempo&quot;, true, false)
	if contador_label and contador_label is Label3D:
		contador_label.text = &quot;00:00&quot;
		video_instance.set_meta(&quot;contador_label_path&quot;, video_instance.get_path_to(contador_label))
		print(&quot;‚úÖ [UI] Contador configurado&quot;)

# Configurar autoplay para runtime
func _configurar_autoplay_runtime(video_instance: Node3D, video_player: VideoStreamPlayer, audio_player_3d = null):
	# Guardar metadata
	video_instance.set_meta(&quot;autoplay_runtime&quot;, true)
	video_instance.set_meta(&quot;video_player_path&quot;, video_instance.get_path_to(video_player))
	video_instance.set_meta(&quot;enable_3d_audio&quot;, enable_3d_audio)
	
	if audio_player_3d:
		video_instance.set_meta(&quot;audio_player_3d_path&quot;, video_instance.get_path_to(audio_player_3d))
	
	# Script para runtime
	var script_code = &quot;&quot;&quot;extends Node3D

var video_player: VideoStreamPlayer
var audio_player_3d: AudioStreamPlayer3D
var contador_label: Label3D
var mesh_instance: MeshInstance3D
var has_3d_audio: bool = false
var sync_tolerance: float = 0.1

func _ready():
	if not Engine.is_editor_hint() and has_meta(&quot;autoplay_runtime&quot;):
		print(&quot;üé¨ [Runtime] Configurando video...&quot;)
		
		_configurar_referencias()
		_configurar_textura_video()
		_iniciar_reproduccion()

func _configurar_referencias():
	# Video player
	if has_meta(&quot;video_player_path&quot;):
		video_player = get_node(get_meta(&quot;video_player_path&quot;))
	
	# Contador
	if has_meta(&quot;contador_label_path&quot;):
		contador_label = get_node(get_meta(&quot;contador_label_path&quot;))
	
	# Audio 3D
	has_3d_audio = get_meta(&quot;enable_3d_audio&quot;, false)
	if has_3d_audio and has_meta(&quot;audio_player_3d_path&quot;):
		audio_player_3d = get_node(get_meta(&quot;audio_player_3d_path&quot;))
		print(&quot;üîä [Runtime] Audio 3D encontrado&quot;)
	
	# Mesh
	mesh_instance = _encontrar_mesh_instance(self)

func _configurar_textura_video():
	if video_player and mesh_instance and mesh_instance.mesh:
		var material = mesh_instance.mesh.material
		if material is StandardMaterial3D:
			material.albedo_texture = video_player.get_video_texture()

func _iniciar_reproduccion():
	if video_player:
		video_player.play()
		print(&quot;üé¨ [Runtime] Video iniciado: &quot;, name)
	
	if has_3d_audio and audio_player_3d:
		audio_player_3d.play()
		print(&quot;üîä [Runtime] Audio 3D iniciado: &quot;, name)

func _process(_delta):
	if video_player and video_player.is_playing():
		# Actualizar contador
		if contador_label:
			_actualizar_contador()
		
		# Sincronizar audio 3D
		if has_3d_audio and audio_player_3d:
			_sincronizar_audio_3d()
		
		# Ajustar dimensiones del mesh
		_ajustar_dimensiones_mesh()

func _actualizar_contador():
	var tiempo = video_player.stream_position
	var minutos = int(tiempo / 60)
	var segundos = int(tiempo) % 60
	contador_label.text = &quot;%02d:%02d&quot; % [minutos, segundos]

func _sincronizar_audio_3d():
	# Sincronizar estado
	if video_player.is_playing() and not audio_player_3d.playing:
		audio_player_3d.play()
	elif not video_player.is_playing() and audio_player_3d.playing:
		audio_player_3d.stop()
	
	# Sincronizar posici√≥n si ambos est√°n reproduci√©ndose
	if video_player.is_playing() and audio_player_3d.playing:
		var video_pos = video_player.stream_position
		var audio_pos = audio_player_3d.get_playback_position()
		
		if abs(video_pos - audio_pos) &gt; sync_tolerance:
			audio_player_3d.seek(video_pos)

func _ajustar_dimensiones_mesh():
	if not mesh_instance or not mesh_instance.mesh:
		return
	
	var video_texture = video_player.get_video_texture()
	if video_texture and video_texture.get_width() &gt; 0:
		var width = video_texture.get_width()
		var height = video_texture.get_height()
		var new_size = _calcular_tama√±o_proporcional(width, height)
		
		if mesh_instance.mesh is QuadMesh:
			var current_size = mesh_instance.mesh.size
			if abs(current_size.x - new_size.x) &gt; 0.01 or abs(current_size.y - new_size.y) &gt; 0.01:
				mesh_instance.mesh.size = new_size

func _calcular_tama√±o_proporcional(width: int, height: int) -&gt; Vector2:
	var MAX_SIZE: float = 2.0
	var scale_factor: float
	
	if width &gt;= height:
		scale_factor = MAX_SIZE / width
		return Vector2(MAX_SIZE, height * scale_factor)
	else:
		scale_factor = MAX_SIZE / height
		return Vector2(width * scale_factor, MAX_SIZE)

func _encontrar_mesh_instance(node: Node) -&gt; MeshInstance3D:
	if node is MeshInstance3D:
		return node
	for child in node.get_children():
		var found = _encontrar_mesh_instance(child)
		if found:
			return found
	return null
&quot;&quot;&quot;
	
	var script = GDScript.new()
	script.source_code = script_code
	video_instance.set_script(script)

# Funciones auxiliares
func _calcular_tama√±o(width: int, height: int) -&gt; Vector2:
	var scale_factor: float
	if width &gt;= height:
		scale_factor = MAX_SIZE / width
		return Vector2(MAX_SIZE, height * scale_factor)
	else:
		scale_factor = MAX_SIZE / height
		return Vector2(width * scale_factor, MAX_SIZE)

func _encontrar_video_player(node: Node) -&gt; VideoStreamPlayer:
	if node is VideoStreamPlayer:
		return node
	for child in node.get_children():
		var found = _encontrar_video_player(child)
		if found:
			return found
	return null

func _encontrar_mesh_instance(node: Node) -&gt; MeshInstance3D:
	if node is MeshInstance3D:
		return node
	for child in node.get_children():
		var found = _encontrar_mesh_instance(child)
		if found:
			return found
	return null

func _hacer_nodos_locales(node: Node):
	if Engine.is_editor_hint():
		node.set_scene_file_path(&quot;&quot;)
		for child in node.get_children():
			_hacer_nodos_locales(child)

func _configurar_nombre_unico(video_instance: Node3D):
	var base_name = current_video_real_path.get_file().get_basename()
	var suffix = &quot;_3D&quot; if enable_3d_audio else &quot;&quot;
	var timestamp = str(Time.get_unix_time_from_system())
	video_instance.name = &quot;Video_&quot; + base_name + suffix + &quot;_&quot; + timestamp

func _get_real_path(uid_path: String) -&gt; String:
	if uid_path.begins_with(&quot;uid://&quot;):
		var uid_id = ResourceUID.text_to_id(uid_path)
		var real_path = ResourceUID.get_id_path(uid_id)
		if real_path != &quot;&quot;:
			return real_path
		else:
			print(&quot;‚ö†Ô∏è [UID] No se pudo resolver: &quot;, uid_path)
			return uid_path
	return uid_path

# Mensajes de ayuda
func _mostrar_ayuda_formato():
	print(&quot;üí° SUGERENCIA: Godot 4 solo soporta formato .ogv (Ogg Theora)&quot;)
	print(&quot;üí° Convierte con: ffmpeg -i video.mp4 -codec:v libtheora -qscale:v 9 -codec:a libvorbis -qscale:a 8 -r 30 video.ogv&quot;)

func _mostrar_ayuda_audio_3d():
	print(&quot;üí° Para usar Audio 3D, extrae el audio del video:&quot;)
	print(&quot;üí° ffmpeg -i &quot;, current_video_real_path.get_file(), &quot; -vn -acodec libvorbis -q:a 8 &quot;, current_video_real_path.get_file().get_basename(), &quot;_audio.ogg&quot;)
	print(&quot;üí° Coloca el archivo .ogg en la misma carpeta que el video&quot;)
</code></pre>
    </div>
    

    <div class="code-div">
        <div class="link-file">
        <a class="file-name" href="/project/dis3Dbusi/godotVersion/scripts/dis3Dbusi/classes/tiposArchivos/video.gd.uid">video.gd.uid</a>
        </div>
        <pre class="code-file"><code>uid://yexqklnnk5by
</code></pre>
    </div>
    

    <div class="code-div">
        <div class="link-file">
        <a class="file-name" href="/project/dis3Dbusi/godotVersion/scripts/dis3Dbusi/classes/tiposArchivos/imagen.gd">imagen.gd</a>
        </div>
        <pre class="code-file"><code>extends Node3D
class_name Imagen

var image_scene_path = &quot;res://scenes/files/image.tscn&quot;
var MAX_SIZE: float = 1.0

# Funci√≥n principal: crear y configurar una escena de imagen
func crear_escena_imagen(image_path: String) -&gt; Node3D:
	# Cargar la escena de imagen
	var image_scene = ResourceLoader.load(image_scene_path)
	if not image_scene:
		print(&quot;‚ùå Error: No se pudo cargar la escena de imagen en: &quot;, image_scene_path)
		return null
	
	# Instanciar la escena
	var image_instance = image_scene.instantiate()
	
	# IMPORTANTE: Desconectar de la plantilla para evitar superposici√≥n
	image_instance.scene_file_path = &quot;&quot;
	
	# Buscar el MeshInstance3D en la escena instanciada
	var mesh_instance = _encontrar_mesh_instance(image_instance)
	
	if not mesh_instance:
		print(&quot;‚ö†Ô∏è No se encontr√≥ MeshInstance3D en la escena: &quot;, image_scene_path)
		image_instance.queue_free()
		return null
	
	# Cargar la textura de imagen
	var texture = ResourceLoader.load(image_path)
	if not texture:
		print(&quot;‚ùå Error cargando textura de imagen: &quot;, image_path)
		image_instance.queue_free()
		return null
	
	# Configurar el mesh con la textura (creando recursos √∫nicos)
	_configurar_mesh_con_textura(mesh_instance, texture)
	
	print(&quot;‚úÖ Imagen cargada correctamente: &quot;, image_path.get_file())
	
	# Hacer que todos los nodos sean locales al √°rbol (desconectar de plantilla)
	_hacer_nodos_locales(image_instance)
	
	# Ocultar hijos del nodo en el editor (colapsado)
	if Engine.is_editor_hint():
		image_instance.set_display_folded(true)
	
	# Configurar texto de t√≠tulo
	_configurar_texto_titulo(image_instance, image_path)
	
	# Asignar un nombre √∫nico a la instancia para evitar conflictos
	var nombre_archivo = _get_real_path(image_path).get_file().get_basename()
	image_instance.name = &quot;Image_&quot; + nombre_archivo + &quot;_&quot; + str(Time.get_unix_time_from_system())
	
	return image_instance

func _configurar_texto_titulo(image_instance: Node3D, image_path: String):
	# Buscar el nodo de texto 3D por nombre
	var titulo_label = image_instance.find_child(&quot;TituloImagen&quot;, true, false)
	
	# Configurar t√≠tulo del archivo
	if titulo_label and titulo_label is Label3D:
		var nombre_archivo = _get_real_path(image_path).replace(&quot;res://&quot;, &quot;&quot;)
		titulo_label.text = nombre_archivo
		print(&quot;‚úÖ T√≠tulo 3D configurado: &quot;, nombre_archivo)
	else:
		print(&quot;‚ö†Ô∏è No se encontr√≥ el nodo &#x27;TituloImagen&#x27; (Label3D) en la escena&quot;)

func _configurar_mesh_con_textura(mesh_instance: MeshInstance3D, texture: Texture2D):
	# Crear material √∫nico con la textura
	var material = StandardMaterial3D.new()
	material.albedo_texture = texture
	material.cull_mode = BaseMaterial3D.CULL_DISABLED
	
	# Configurar transparencia si la imagen tiene canal alpha
	if _tiene_canal_alpha(texture):
		material.transparency = BaseMaterial3D.TRANSPARENCY_ALPHA_SCISSOR
		material.no_depth_test = false
		material.shading_mode = BaseMaterial3D.SHADING_MODE_PER_PIXEL
		print(&quot;‚úÖ Configurada transparencia alpha scissor para imagen con canal alpha&quot;)
	
	# Calcular tama√±o apropiado manteniendo proporci√≥n
	var size = _calcular_tama√±o(texture.get_width(), texture.get_height())
	
	# IMPORTANTE: Duplicar el mesh existente o crear uno nuevo para evitar compartir recursos
	var quad_mesh: QuadMesh
	if mesh_instance.mesh and mesh_instance.mesh is QuadMesh:
		# Duplicar el mesh existente para que cada instancia tenga el suyo propio
		quad_mesh = mesh_instance.mesh.duplicate()
	else:
		# Crear un mesh completamente nuevo
		quad_mesh = QuadMesh.new()
	
	# Configurar el quad con el material √∫nico
	quad_mesh.size = size
	quad_mesh.material = material
	
	# Asignar el mesh √∫nico a esta instancia
	mesh_instance.mesh = quad_mesh
	
	print(&quot;‚úÖ Mesh y material √∫nicos creados para la instancia&quot;)

func _tiene_canal_alpha(texture: Texture2D) -&gt; bool:
	# Verificar si la textura tiene canal alpha
	if texture is ImageTexture:
		var image = texture.get_image()
		if image:
			var format = image.get_format()
			# Verificar formatos que incluyen alpha en Godot 4
			return format in [
				Image.FORMAT_RGBA8,
				Image.FORMAT_RGBA4444,
				Image.FORMAT_RGBAF,
				Image.FORMAT_RGBAH
			]
	elif texture.has_method(&quot;get_format&quot;):
		# Para otros tipos de textura que puedan tener informaci√≥n de formato
		var format_info = str(texture)
		return &quot;RGBA&quot; in format_info or &quot;alpha&quot; in format_info.to_lower()
	
	# Si no podemos determinar, asumir que podr√≠a tener alpha para PNG y similares
	var path = str(texture.resource_path).to_lower()
	return path.ends_with(&quot;.png&quot;) or path.ends_with(&quot;.webp&quot;)

func _calcular_tama√±o(width: int, height: int) -&gt; Vector2:
	var scale_factor: float
	var final_width = MAX_SIZE
	var final_height = MAX_SIZE
	
	if width &gt;= height:
		scale_factor = MAX_SIZE / width
		final_height = height * scale_factor
	else:
		scale_factor = MAX_SIZE / height
		final_width = width * scale_factor
	
	return Vector2(final_width, final_height)

func _encontrar_mesh_instance(node: Node) -&gt; MeshInstance3D:
	# Buscar MeshInstance3D en el nodo y sus hijos
	if node is MeshInstance3D:
		return node as MeshInstance3D
	
	for child in node.get_children():
		var found = _encontrar_mesh_instance(child)
		if found:
			return found
	
	return null

func _hacer_nodos_locales(node: Node):
	# Hacer que el nodo sea local (desconectado de la plantilla)
	if Engine.is_editor_hint():
		# En el editor, hacer que el nodo no tenga referencia a escena externa
		node.set_scene_file_path(&quot;&quot;)
		
		# Hacer que todos los hijos tambi√©n sean locales
		for child in node.get_children():
			_hacer_nodos_locales(child)
	
	print(&quot;‚úÖ Nodos desconectados de la plantilla - ahora son independientes&quot;)

func _get_real_path(uid_path: String) -&gt; String:
	if uid_path.begins_with(&quot;uid://&quot;):
		return ResourceUID.get_id_path(ResourceUID.text_to_id(uid_path))
	return uid_path
</code></pre>
    </div>
    

    <div class="code-div">
        <div class="link-file">
        <a class="file-name" href="/project/dis3Dbusi/godotVersion/scripts/dis3Dbusi/classes/tiposArchivos/imagen.gd.uid">imagen.gd.uid</a>
        </div>
        <pre class="code-file"><code>uid://crdhaj7au6luf
</code></pre>
    </div>
    

    <div class="code-div">
        <div class="link-file">
        <a class="file-name" href="/project/dis3Dbusi/godotVersion/scripts/dis3Dbusi/classes/tiposArchivos/audio.gd.uid">audio.gd.uid</a>
        </div>
        <pre class="code-file"><code>uid://si6iqm38ywvb
</code></pre>
    </div>
    

    <div class="code-div">
        <div class="link-file">
        <a class="file-name" href="/project/dis3Dbusi/godotVersion/scripts/dis3Dbusi/classes/tiposArchivos/audio.gd">audio.gd</a>
        </div>
        <pre class="code-file"><code>extends Node3D
class_name Audio

var audio_scene_path = &quot;res://scenes/files/audio.tscn&quot;
var auto_play: bool = true
var loop_audio: bool = true
var volume_db: float = 0.0
var unit_size: float = 10.0
var max_distance: float = 10.0
var attenuation_model: AudioStreamPlayer3D.AttenuationModel = AudioStreamPlayer3D.ATTENUATION_INVERSE_DISTANCE
var doppler_tracking: AudioStreamPlayer3D.DopplerTracking = AudioStreamPlayer3D.DOPPLER_TRACKING_DISABLED

# Funci√≥n principal: crear y configurar una escena de audio
func crear_escena_audio(audio_path: String) -&gt; Node3D:
	# Cargar la escena de audio
	var audio_scene = ResourceLoader.load(audio_scene_path)
	if not audio_scene:
		print(&quot;‚ùå Error: No se pudo cargar la escena de audio en: &quot;, audio_scene_path)
		return null
	
	# Instanciar la escena
	var audio_instance = audio_scene.instantiate()
	
	# IMPORTANTE: Desconectar de la plantilla para evitar superposici√≥n
	audio_instance.scene_file_path = &quot;&quot;
	
	# Buscar el AudioStreamPlayer3D en la escena instanciada
	var audio_player = _encontrar_audio_player(audio_instance)
	
	if not audio_player:
		print(&quot;‚ö†Ô∏è No se encontr√≥ AudioStreamPlayer3D en la escena: &quot;, audio_scene_path)
		audio_instance.queue_free()
		return null
	
	# Cargar el stream de audio
	var audio_stream = ResourceLoader.load(audio_path)
	if not audio_stream:
		print(&quot;‚ùå Error cargando stream de audio: &quot;, audio_path)
		audio_instance.queue_free()
		return null
	
	# Configurar el audio player con todos los par√°metros
	audio_player.stream = audio_stream
	audio_player.volume_db = volume_db
	audio_player.unit_size = unit_size
	audio_player.max_distance = max_distance
	audio_player.attenuation_model = attenuation_model
	audio_player.doppler_tracking = doppler_tracking
	
	# Configurar loop dependiendo del tipo de stream
	if loop_audio:
		_configurar_loop_audio(audio_stream)
	
	# No reproducir en el editor, solo configurar para runtime
	if auto_play and not Engine.is_editor_hint():
		audio_player.play()
	
	print(&quot;‚úÖ Audio cargado correctamente: &quot;, audio_path.get_file())
	
	# Hacer que todos los nodos sean locales al √°rbol (desconectar de plantilla)
	_hacer_nodos_locales(audio_instance)
	
	# Ocultar hijos del nodo en el editor (colapsado)
	if Engine.is_editor_hint():
		audio_instance.set_display_folded(true)
	
	# Configurar auto-reproducci√≥n en runtime
	if auto_play:
		_configurar_autoplay_runtime(audio_instance, audio_player)
	
	# Configurar textos de t√≠tulo y contador de tiempo
	_configurar_textos_ui(audio_instance, audio_path, audio_player)
	
	return audio_instance

func _hacer_nodos_locales(node: Node):
	# Hacer que el nodo sea local (desconectado de la plantilla)
	if Engine.is_editor_hint():
		# En el editor, hacer que el nodo no tenga referencia a escena externa
		node.set_scene_file_path(&quot;&quot;)
		
		# Hacer que todos los hijos tambi√©n sean locales
		for child in node.get_children():
			_hacer_nodos_locales(child)
	
	print(&quot;‚úÖ Nodos desconectados de la plantilla - ahora son independientes&quot;)

func _configurar_textos_ui(audio_instance: Node3D, audio_path: String, audio_player: AudioStreamPlayer3D):
	# Buscar los nodos de texto 3D por nombre
	var titulo_label = audio_instance.find_child(&quot;TituloAudio&quot;, true, false)
	var contador_label = audio_instance.find_child(&quot;ContadorTiempo&quot;, true, false)
	
	# Configurar t√≠tulo del archivo
	if titulo_label and titulo_label is Label3D:
		var nombre_archivo = ResourceUID.get_id_path(ResourceUID.text_to_id(audio_path)).replace(&quot;res://&quot;, &quot;&quot;)
		titulo_label.text = nombre_archivo
		print(&quot;‚úÖ T√≠tulo 3D configurado: &quot;, nombre_archivo)
	else:
		print(&quot;‚ö†Ô∏è No se encontr√≥ el nodo &#x27;TituloAudio&#x27; (Label3D) en la escena&quot;)
	
	# Configurar contador de tiempo
	if contador_label and contador_label is Label3D:
		contador_label.text = &quot;00:00 / 00:00&quot;
		# A√±adir metadata para el script de runtime
		audio_instance.set_meta(&quot;contador_label_path&quot;, audio_instance.get_path_to(contador_label))
		print(&quot;‚úÖ Contador de tiempo 3D configurado&quot;)
	else:
		print(&quot;‚ö†Ô∏è No se encontr√≥ el nodo &#x27;ContadorTiempo&#x27; (Label3D) en la escena&quot;)

func _configurar_loop_audio(audio_stream: AudioStream):
	# Para diferentes tipos de audio streams
	if audio_stream.has_method(&quot;set_loop&quot;):
		audio_stream.set_loop(true)
	elif &quot;loop&quot; in audio_stream:
		audio_stream.loop = true
	elif audio_stream.has_method(&quot;set_loop_mode&quot;):
		# Para AudioStreamWAV
		audio_stream.set_loop_mode(AudioStreamWAV.LOOP_FORWARD)
	elif &quot;loop_mode&quot; in audio_stream:
		# Para AudioStreamWAV
		audio_stream.loop_mode = AudioStreamWAV.LOOP_FORWARD
	else:
		print(&quot;‚ö†Ô∏è No se pudo configurar loop para el tipo de audio: &quot;, audio_stream.get_class())

func _configurar_autoplay_runtime(audio_instance: Node3D, audio_player: AudioStreamPlayer3D):
	# A√±adir metadata para que el nodo sepa que debe reproducirse en runtime
	audio_instance.set_meta(&quot;autoplay_runtime&quot;, true)
	audio_instance.set_meta(&quot;audio_player_path&quot;, audio_instance.get_path_to(audio_player))
	
	# Crear un script completo para autoplay y contador de tiempo
	var script_code = &quot;&quot;&quot;extends Node3D

var audio_player: AudioStreamPlayer3D
var contador_label: Label3D

func _ready():
	if not Engine.is_editor_hint() and has_meta(&quot;autoplay_runtime&quot;):
		# Configurar audio player
		var player_path = get_meta(&quot;audio_player_path&quot;)
		audio_player = get_node(player_path)
		
		# Configurar contador de tiempo
		if has_meta(&quot;contador_label_path&quot;):
			var contador_path = get_meta(&quot;contador_label_path&quot;)
			contador_label = get_node(contador_path)
		
		# Iniciar reproducci√≥n
		if audio_player and audio_player is AudioStreamPlayer3D:
			audio_player.play()
			print(&quot;üîä Audio iniciado autom√°ticamente: &quot;, name)

func _process(_delta):
	if audio_player and contador_label and audio_player.playing:
		_actualizar_contador_tiempo()

func _actualizar_contador_tiempo():
	var tiempo_actual = audio_player.get_playback_position()
	var duracion_total = audio_player.stream.get_length()
	
	var minutos_actual = int(tiempo_actual / 60)
	var segundos_actual = int(tiempo_actual) % 60
	var minutos_total = int(duracion_total / 60)
	var segundos_total = int(duracion_total) % 60
	
	contador_label.text = &quot;%02d:%02d / %02d:%02d&quot; % [minutos_actual, segundos_actual, minutos_total, segundos_total]
&quot;&quot;&quot;
	
	var script = GDScript.new()
	script.source_code = script_code
	audio_instance.set_script(script)

func _encontrar_audio_player(node: Node) -&gt; AudioStreamPlayer3D:
	# Buscar AudioStreamPlayer3D en el nodo y sus hijos
	if node is AudioStreamPlayer3D:
		return node as AudioStreamPlayer3D
	
	for child in node.get_children():
		var found = _encontrar_audio_player(child)
		if found:
			return found
	
	return null
</code></pre>
    </div>
    
            </div>
        
        <div class="footer"><p>Made by non-archive team. inspired by Distribusi</p></div>
        </main>
        <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/4.0.0/model-viewer.min.js"></script>
        </body>
    </html>
    